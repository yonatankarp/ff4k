{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FF4K - Feature Flags for Kotlin","text":"<p>FF4K is a Kotlin Multiplatform (KMP) implementation of the popular FF4J (Feature Flipping for Java) library. It brings robust feature flagging capabilities to the Kotlin ecosystem, supporting multiplatform projects.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Kotlin Multiplatform: Designed to work across different platforms supported by Kotlin (JVM, Android, Native, etc.).</li> <li>Type-safe Properties: Strongly typed property definitions (String, Int, Boolean, etc.).</li> <li>Serialization Support: Built-in support for <code>kotlinx.serialization</code>.</li> <li>Extensible: Easily implement custom storage backends (Redis, SQL, etc.).</li> <li>DSL: Intuitive Domain Specific Language for configuration.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Add the dependency to your <code>build.gradle.kts</code>:</p> <pre><code>dependencies {\n    implementation(\"com.yonatankarp:ff4k-core:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>import com.yonatankarp.ff4k.dsl.core.ff4k\n\nsuspend fun main() {\n    val ff4k = ff4k {\n        features {\n            feature(\"dark-mode\") {\n                isEnabled = true\n                description = \"Enable dark mode theme\"\n            }\n        }\n    }\n\n    // Check feature status\n    ff4k.ifEnabled(\"dark-mode\") {\n        // ...\n    }\n}\n</code></pre> <p>Check out the Usage guide for more details.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache License 2.0.</p>"},{"location":"extending/","title":"Extending FF4K","text":"<p>FF4K is designed to be extensible. You can implement custom storage backends for features and properties to persist your flags in databases, remote services (like Redis, Consul), or local files.</p>"},{"location":"extending/#implementing-a-feature-store","title":"Implementing a Feature Store","text":"<p>To create a custom feature store, implement the <code>FeatureStore</code> interface. For convenience, it is highly recommended to extend <code>AbstractFeatureStore</code>, which handles most of the common logic and boilerplate.</p>"},{"location":"extending/#using-abstractfeaturestore","title":"Using AbstractFeatureStore","text":"<p><code>AbstractFeatureStore</code> provides default implementations for group management, permission handling helper methods, and validation. You primarily need to implement the core CRUD operations.</p> <pre><code>import com.yonatankarp.ff4k.core.Feature\nimport com.yonatankarp.ff4k.exception.FeatureAlreadyExistsException\nimport com.yonatankarp.ff4k.exception.FeatureNotFoundException\nimport com.yonatankarp.ff4k.store.AbstractFeatureStore\n\nclass MyCustomFeatureStore : AbstractFeatureStore() {\n\n    // Helper map to simulate a DB for this example\n    private val db = mutableMapOf&lt;String, Feature&gt;()\n\n    override suspend fun get(featureId: String): Feature? {\n        return db[featureId]\n    }\n\n    override suspend fun getAll(): Map&lt;String, Feature&gt; {\n        return db.toMap()\n    }\n\n    // Using the 'plusAssign' operator for creation (store += feature)\n    override suspend fun plusAssign(feature: Feature) {\n        if (feature.uid in db) {\n            throw FeatureAlreadyExistsException(feature.uid)\n        }\n        db[feature.uid] = feature\n    }\n\n    // Using the 'minusAssign' operator for deletion (store -= featureId)\n    override suspend fun minusAssign(featureId: String) {\n         if (featureId !in db) {\n            throw FeatureNotFoundException(featureId)\n        }\n        db.remove(featureId)\n    }\n\n    override suspend fun update(feature: Feature) {\n         if (feature.uid !in db) {\n            throw FeatureNotFoundException(feature.uid)\n        }\n        db[feature.uid] = feature\n    }\n\n    override suspend fun clear() {\n        db.clear()\n    }\n\n    // ... implement other abstract methods ...\n}\n</code></pre>"},{"location":"extending/#implementing-a-property-store","title":"Implementing a Property Store","text":"<p>Similarly, to create a custom property store, implement the <code>PropertyStore</code> interface.</p> <pre><code>import com.yonatankarp.ff4k.core.PropertyStore\nimport com.yonatankarp.ff4k.property.Property\n\nclass MyCustomPropertyStore : PropertyStore {\n   // Implement interface...\n}\n</code></pre>"},{"location":"extending/#verifying-your-implementation","title":"Verifying Your Implementation","text":"<p>It is critical to ensure your custom store behaves correctly. FF4K provides a Contract Test Suite that you can use to automatically verify your implementation against the expected behavior.</p>"},{"location":"extending/#registering-your-store","title":"Registering Your Store","text":"<p>Once implemented, pass your custom store to the <code>ff4k</code> configuration function.</p> <pre><code>suspend fun main() {\n    val ff4k = ff4k(\n        featureStore = MyCustomFeatureStore(),\n        propertyStore = MyCustomPropertyStore()\n    ) {\n        // ...\n    }\n}\n</code></pre>"},{"location":"properties/","title":"Properties","text":"<p>Properties in FF4K allow you to manage configuration values alongside your feature flags. Unlike feature flags which are boolean, properties can hold values of various types.</p>"},{"location":"properties/#built-in-property-types","title":"Built-in Property Types","text":"<p>FF4K comes with support for common data types out of the box:</p> <ul> <li><code>PropertyString</code></li> <li><code>PropertyInt</code></li> <li><code>PropertyLong</code></li> <li><code>PropertyDouble</code></li> <li><code>PropertyFloat</code></li> <li><code>PropertyBoolean</code></li> <li><code>PropertyByte</code></li> <li><code>PropertyShort</code></li> <li><code>PropertyBigInteger</code></li> <li><code>PropertyBigDecimal</code></li> <li><code>PropertyLocalDate</code></li> <li><code>PropertyLocalDateTime</code></li> <li><code>PropertyInstant</code></li> <li><code>PropertyLogLevel</code></li> </ul>"},{"location":"properties/#usage","title":"Usage","text":""},{"location":"properties/#defining-properties-in-dsl","title":"Defining Properties in DSL","text":"<p>You can define properties within the <code>properties</code> block of the <code>ff4k</code> DSL.</p> <pre><code>suspend fun main() {\n    val ff4k = ff4k {\n        properties {\n            property(\"app-title\") {\n                value = \"My Awesome App\"\n            }\n\n            property(\"max-connections\") {\n                value = 10\n                description = \"Maximum number of concurrent connections\"\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"properties/#retrieving-properties","title":"Retrieving Properties","text":"<p>To retrieve a property, use the <code>property</code> method. You should specify the expected type.</p> <pre><code>// Get the property object\nval titleProp: Property&lt;String&gt;? = ff4k.property&lt;String&gt;(\"app-title\")\nprintln(\"Title: ${titleProp?.value}\")\n\n// Get value directly (safe)\nval maxConns: Int? = ff4k.property&lt;Int&gt;(\"max-connections\")?.value\n</code></pre>"},{"location":"properties/#creating-custom-properties","title":"Creating Custom Properties","text":"<p>If the built-in types don't meet your needs, you can create custom property types by implementing the <code>Property&lt;T&gt;</code> interface or extending <code>AbstractProperty&lt;T&gt;</code>.</p>"},{"location":"properties/#1-implement-the-interface","title":"1. Implement the Interface","text":"<p>You need to implement <code>Property&lt;T&gt;</code>. It's recommended to make your implementation a data class and include serialization support.</p> <pre><code>import com.yonatankarp.ff4k.property.Property\nimport kotlinx.serialization.Serializable\n\n@Serializable\ndata class PropertyColor(\n    override val name: String,\n    override val value: String, // Storing hex code as string\n    override val description: String? = null,\n    override val fixedValues: Set&lt;String&gt; = emptySet(),\n    override val readOnly: Boolean = false\n) : Property&lt;String&gt;\n</code></pre>"},{"location":"properties/#2-using-custom-properties","title":"2. Using Custom Properties","text":"<p>You can manually add custom properties to the store. Here is a complete example of how to register and use a custom property type:</p> <pre><code>suspend fun main() {\n    // 1. Initialize your property store\n    val myPropertyStore = InMemoryPropertyStore()\n\n    // 2. Initialize FF4K with your store\n    val ff4k = ff4k(propertyStore = myPropertyStore) {\n        // ... other configuration ...\n    }\n\n    // 3. Create your custom property\n    val brandColor = PropertyColor(\n        name = \"brand-color\",\n        value = \"#FF5722\",\n        description = \"Primary brand color\"\n    )\n\n    // 4. Add it to the store manually\n    myPropertyStore += brandColor\n\n    // 5. Retrieve and use it\n    val storedColor = ff4k.property&lt;String&gt;(\"brand-color\")\n    println(\"Brand Color: ${storedColor?.value}\") // Output: #FF5722\n}\n</code></pre>"},{"location":"testing/","title":"Contract Testing","text":"<p>The <code>ff4k-contract-test</code> module provides a suite of reusable tests to verify that your custom <code>FeatureStore</code> and <code>PropertyStore</code> implementations adhere to the FF4K specification. This ensures consistency and reliability across different storage backends.</p>"},{"location":"testing/#setup","title":"Setup","text":"<p>First, add the contract test dependency to your project.</p> <p>Gradle (Kotlin DSL)</p> <pre><code>dependencies {\n    testImplementation(\"com.yonatankarp:ff4k-contract-test:&lt;version&gt;\")\n}\n</code></pre>"},{"location":"testing/#testing-a-feature-store","title":"Testing a Feature Store","text":"<p>To test your custom <code>FeatureStore</code>, create a test class that extends <code>FeatureStoreContractTest</code> and implement the <code>createStore</code> method.</p> <pre><code>import com.yonatankarp.ff4k.test.contract.store.FeatureStoreContractTest\nimport com.yonatankarp.ff4k.core.FeatureStore\n\nclass MyCustomFeatureStoreTest : FeatureStoreContractTest() {\n\n    // This method is called before each test to provide a fresh store instance\n    override suspend fun createStore(): FeatureStore {\n        // Return a fresh instance of your store\n        // If your store relies on an external DB, ensure it's cleaned up here\n        return MyCustomFeatureStore()\n    }\n}\n</code></pre> <p>The <code>FeatureStoreContractTest</code> will automatically run a comprehensive set of tests covering: - basic CRUD (Create, Read, Update, Delete) - toggling features - group operations (enable/disable group, add/remove from group) - permissions - error handling (e.g., throwing correct exceptions for missing features)</p>"},{"location":"testing/#testing-properties","title":"Testing Properties","text":"<p>To test custom <code>Property</code> implementations, you can extend <code>PropertyContractTest</code>.</p> <pre><code>import com.yonatankarp.ff4k.test.contract.property.PropertyContractTest\n\nclass MyPropertyTest : PropertyContractTest&lt;String, MyStringProperty&gt;() {\n    override val serializer = MyStringProperty.serializer()\n\n    override fun create(\n        name: String,\n        value: String,\n        description: String?,\n        fixedValues: Set&lt;String&gt;,\n        readOnly: Boolean\n    ) = MyStringProperty(name, value, description, fixedValues, readOnly)\n\n    override fun sampleName() = \"test-prop\"\n    override fun sampleValue() = \"value\"\n    override fun otherValueNotInFixedValues() = \"other-value\"\n    override fun fixedValuesIncludingSample(sample: String) = setOf(sample, \"other\")\n}\n</code></pre>"},{"location":"testing/#running-tests","title":"Running Tests","text":"<p>Run your tests as you normally would using Gradle:</p> <pre><code>./gradlew test\n</code></pre>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide covers the core concepts and usage patterns of FF4K.</p>"},{"location":"usage/#initialization","title":"Initialization","text":"<p>The entry point for FF4K is the <code>ff4k</code> DSL function. It allows you to configure features and properties and returns an <code>FF4k</code> instance.</p> <pre><code>import com.yonatankarp.ff4k.dsl.core.ff4k\n\nsuspend fun main() {\n    val ff4k = ff4k {\n        // Configuration block\n    }\n}\n</code></pre>"},{"location":"usage/#configuration-options","title":"Configuration Options","text":"<p>The <code>ff4k</code> function accepts several optional arguments to customize behavior:</p> <pre><code>suspend fun main() {\n    val ff4k = ff4k(\n        autoCreate = true,                // Automatically create missing features (default: false)\n        featureStore = InMemoryFeatureStore(), // Custom feature store (default: InMemory)\n        propertyStore = InMemoryPropertyStore() // Custom property store (default: InMemory)\n    ) {\n        // ...\n    }\n}\n</code></pre> <ul> <li><code>autoCreate</code>: If set to <code>true</code>, querying a feature that doesn't exist will automatically create it in the store (disabled by default).</li> <li><code>featureStore</code>: The backend storage for feature flags.</li> <li><code>propertyStore</code>: The backend storage for properties.</li> </ul>"},{"location":"usage/#defining-features","title":"Defining Features","text":"<p>Features are boolean flags that can be toggled on or off. You can define them within the <code>features</code> block.</p> <pre><code>suspend fun main() {\n    val ff4k = ff4k {\n        features {\n            // Minimal definition\n            feature(\"simple-feature\")\n\n            // Detailed definition\n            feature(\"advanced-feature\") {\n                isEnabled = true\n                description = \"Controls the new dashboard layout\"\n                group = \"ui-beta\"\n                permissions(\"ADMIN\", \"BETA_TESTER\")\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"usage/#feature-attributes","title":"Feature Attributes","text":"<ul> <li><code>uid</code>: Unique identifier for the feature.</li> <li><code>isEnabled</code>: Initial state of the feature (default: <code>false</code>).</li> <li><code>description</code>: Human-readable description.</li> <li><code>group</code>: Group name for organizing features.</li> <li><code>permissions</code>: List of roles/permissions required to access the feature.</li> </ul>"},{"location":"usage/#defining-properties","title":"Defining Properties","text":"<p>Properties are key-value pairs that can store configuration data. They are strongly typed.</p> <pre><code>suspend fun main() {\n    val ff4k = ff4k {\n        properties {\n            // String property\n            property(\"api-url\") {\n                value = \"https://api.example.com\"\n            }\n\n            // Integer property with constraints\n            property(\"max-retries\") {\n                value = 3\n                description = \"Max API retries\"\n                fixedValues(1, 3, 5) // Value must be one of these\n                readOnly = true // Prevent runtime modification\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"usage/#checking-features","title":"Checking Features","text":"<p>There are several ways to check the status of a feature.</p>"},{"location":"usage/#boolean-check","title":"Boolean Check","text":"<p>The <code>check</code> method returns a boolean indicating if the feature is enabled.</p> <pre><code>if (ff4k.check(\"dark-mode\")) {\n    enableDarkMode()\n}\n</code></pre>"},{"location":"usage/#functional-style","title":"Functional Style","text":"<p>The <code>ifEnabled</code> and <code>ifEnabledOrElse</code> extension functions provide a more functional approach.</p> <pre><code>// Execute only if enabled\nff4k.ifEnabled(\"dark-mode\") {\n    enableDarkMode()\n}\n\n// Execute one or the other\nff4k.ifEnabledOrElse(\"dark-mode\",\n    enabled = { \n        println(\"Dark mode is ON\") \n    },\n    disabled = { \n        println(\"Dark mode is OFF\") \n    }\n)\n</code></pre>"},{"location":"usage/#managing-groups","title":"Managing Groups","text":"<p>You can perform operations on entire groups of features.</p> <pre><code>// Enable all features in the 'ui-beta' group\nff4k.enableGroup(\"ui-beta\")\n\n// Disable all features in the 'ui-beta' group\nff4k.disableGroup(\"ui-beta\")\n</code></pre>"},{"location":"usage/#runtime-modification","title":"Runtime Modification","text":"<p>If your store supports it (like the default <code>InMemoryFeatureStore</code>), you can modify features at runtime.</p> <pre><code>// Enable a feature\nff4k.enable(\"my-feature\")\n\n// Disable a feature\nff4k.disable(\"my-feature\")\n</code></pre>"}]}